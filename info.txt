GETTER/SETTER:
public\s+(?<type>\w+)\s+(?<name>\w+)\s*\{\s*(?:(get\s*\{\s*(?<getterBody>[^}]+)\s*\})|(set\s*\{\s*(?<setterBody>[^}]+)\s*\}))\s*\}
public get \l${name}(): ${type} {
    ${getterBody}
}
public set \l${name}(value: ${type}) {
    ${setterBody}
}


GETTER+SETTER:

public\s+(?<type>\w+)\s+(?<name>\w+)\s*\{\s*get\s*\{\s*(?<getterBody>[^}]+)\s*\}\s*set\s*\{\s*(?<setterBody>[^}]+)\s*\}\s*\}
public get \l${name}(): ${type} {
    ${getterBody}
}
public set \l${name}(value: ${type}) {
    ${setterBody}
}




FUNCTION SIG:

public\s+static (?<returnType>\w+(?:<[^>]+>)?)\s+(?<methodName>\w+)\s*\((?<arguments>[^\)]*)\)\s*(?!\{[^}]*\b(get|set)\b)
public static ${methodName}(${arguments}): ${returnType}

FUNCTION ARGS:
(?<=\(|,)\s*(?<argType>\w+(?:<[^>]+>)?(?:\[\])?)\s+(?<argName>\w+)(?=\s*(?:,|\)|=))
${argName}: ${argType}


NULL EXCEPTION:
throw new ArgumentNullException\(\);
throw new Error('ArgumentNullException')

BYTES:
byte\[\]
Uint8Array



















function parseAndReplaceProperties(code) {
    const propertyRegex = /public\s+([\w<>\[\]]+)\s+(\w+)\s*\{/g;
    let match;
    let result = code;
    const replacements = [];

    while ((match = propertyRegex.exec(code)) !== null) {
        const type = match[1];
        const name = match[2];
        const propertyStartIndex = match.index;
        let braceCount = 1;
        let currentIndex = propertyRegex.lastIndex;

        // Find the entire property block by matching braces
        while (braceCount > 0 && currentIndex < code.length) {
            if (code[currentIndex] === '{') {
                braceCount++;
            } else if (code[currentIndex] === '}') {
                braceCount--;
            }
            currentIndex++;
        }

        const propertyBlock = code.substring(propertyStartIndex, currentIndex);

        // Extract getter body while accounting for nested braces
        const getterMatch = /get\s*\{/.exec(propertyBlock);
        let getterBody = null;
        if (getterMatch) {
            let getterStart = getterMatch.index + getterMatch[0].length;
            let getterBraceCount = 1;
            let getterEnd = getterStart;
            while (getterBraceCount > 0 && getterEnd < propertyBlock.length) {
                if (propertyBlock[getterEnd] === '{') {
                    getterBraceCount++;
                } else if (propertyBlock[getterEnd] === '}') {
                    getterBraceCount--;
                }
                getterEnd++;
            }
            getterBody = propertyBlock.substring(getterStart, getterEnd - 1).trim();
        }

        // Extract setter body while accounting for nested braces
        const setterMatch = /set\s*\{/.exec(propertyBlock);
        let setterBody = null;
        if (setterMatch) {
            let setterStart = setterMatch.index + setterMatch[0].length;
            let setterBraceCount = 1;
            let setterEnd = setterStart;
            while (setterBraceCount > 0 && setterEnd < propertyBlock.length) {
                if (propertyBlock[setterEnd] === '{') {
                    setterBraceCount++;
                } else if (propertyBlock[setterEnd] === '}') {
                    setterBraceCount--;
                }
                setterEnd++;
            }
            setterBody = propertyBlock.substring(setterStart, setterEnd - 1).trim();
        }

        function optimizeDataViewUsage(code) {
    // Split the code into lines
    const lines = code.split('\n');
    let optimizedLines = [];
    let inDataViewSequence = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Check if the line contains 'new DataView(this._data.buffer)'
        if (line.includes('new DataView(this._data.buffer)')) {
            // If we are not already in a sequence, add the new view declaration
            if (!inDataViewSequence) {
                optimizedLines.push('        const view = new DataView(this._data.buffer)');
                inDataViewSequence = true;
            }
            // Replace the occurrence with 'view'
            optimizedLines.push(line.replace(/new DataView\(this\._data\.buffer\)/g, 'view'));
        } else {
            // If the line doesn't match, reset the sequence flag
            inDataViewSequence = false;
            optimizedLines.push(line);
        }
    }

    // Join the lines back into a single string
    return optimizedLines.join('\n');
}

        const patchBody = (str) => {
          str = str.replaceAll(/MapType\.IsSubtypeOf\((.+?)\)/gm, 'MapType.IsSubtypeOf(this.mapType, $1)')
          str = str.replaceAll(/BitConverter\.To(\w+)\(Data,\s*(.+?)\)/gm, 'new DataView(this._data.buffer).get$1($2)')
          str = str.replaceAll(/BitConverter\.GetBytes\((.*?)\).CopyTo\(Data,\s(.+?)\);/gm, 'new DataView(this._data.buffer).set($2, $1)')
          str = str.replace(/(\w+?)\.(\w)\(\)/gm, (match, p1, p2) => {
              return `${p1}.${p2.toLowerCase()}`;
          });
          str = str.replaceAll('byte[] bytes = BitConverter.GetBytes(value);', '')
          str = str.replaceAll(/bytes\.CopyTo\(Data,\s(.+?)\);/gm, 'new DataView(this._data.buffer).set($1, value)')
          str = str.replaceAll(/value\.GetBytes\(\).CopyTo\(Data,\s(.+?)\);/g, 'value.getBytes(this._data, $1)')
          str = optimizeDataViewUsage(str)

          str = str.replaceAll('Parent', 'this._parent')
          str = str.replaceAll('this._parent.Bsp', 'this._parent.bsp')
          str = str.replaceAll(/\bData\b/gm, 'this._data')

          str = str.replaceAll(/this\._parent\.bsp.(\w+)\[(.+?)\]\;/gm, (match, p1, p2) => {
  return  `this._parent.bsp.${p1[0].toLowerCase()}${p1.substring(1)}.get(this.${p2[0].toLowerCase()}${p2.substring(1)})`
});

          str = str.replaceAll('MapType == MapType.', 'this.mapType == MapType.')
          str = str.replaceAll('MapType != MapType.', 'this.mapType != MapType.')

          str = str.replaceAll('view.getUInt16', 'view.getUint16')
          str = str.replaceAll('view.setUInt16', 'view.setUint16')

          str = str.replaceAll('view.getUInt32', 'view.getUint32')
          str = str.replaceAll('view.setUInt32', 'view.setUint32')

          str = str.replaceAll('getSingle(', 'getFloat32(')

          str = str.replaceAll('switch (MapType)', 'switch (this.mapType)')
          str = str.replaceAll('switch (LumpVersion)', 'switch (this.lumpVersion)')
          str = str.replaceAll(/for\s*\(int (\w) = 0; (\w) < (\w*); (.*?)\)/gm, (m, p1, p2, p3, p4) => `for (let ${p1} = 0; ${p2} < this.${p3[0].toLowerCase()}${p3.substring(1)}; ${p4})`)

          str = str.replaceAll(/throw new (\w+)Exception\("(.*?)"\);/gm, 'throw new Error(\'$2\')')
          str = str.replaceAll(/IEnumerable\<(\w+)\>/g, '$1[]')
          return str
        }

        if(getterBody)
          getterBody = patchBody(getterBody)
        if(setterBody)
          setterBody = patchBody(setterBody)

        // Create the replacement string
        const newName = name.charAt(0).toLowerCase() + name.slice(1);
        let replacement = `
public get ${newName}(): ${type} {
    ${getterBody.trim() || ''}
}`.trim()
if(setterBody) {
replacement += `
public set ${newName}(value: ${type}) {
    ${setterBody.trim() || ''}
}
`.trim();
}

        // Store the replacement for later
        replacements.push({ start: propertyStartIndex, end: currentIndex, replacement });
    }

    // Replace the original code with the new formatted code in reverse order
    for (let i = replacements.length - 1; i >= 0; i--) {
        const { start, end, replacement } = replacements[i];
        result = result.slice(0, start) + replacement + result.slice(end);
    }

    return result;
}

const code = `

`

const result = parseAndReplaceProperties(code)
console.log(result)
















function parseAndReplace(code) {
    // Replace method signatures with static typing
    code = code.replaceAll(/public\s+static (\w+(?:<[^>]+>)?)\s+(\w+)\s*\(([^)]*)\)\s*(?!\{[^}]*\b(get|set)\b)/g, 'public static $2($3): $1');

    // Replace argument types with TypeScript style typing
    code = code.replaceAll(/(?<=\(|,)\s*(\w+(?:<[^>]+>)?(?:\[\])?)\s+(\w+)(?=\s*(?:,|\)|=))/g, '$2: $1');

    // Replace exception throwing syntax
    code = code.replaceAll(/throw new ArgumentNullException\(\);/g, 'throw new Error(\'ArgumentNullException\')');

    // Replace byte array type
    code = code.replaceAll(/byte\[\]/g, 'Uint8Array');

    code = code.replaceAll('mapType.IsSubtypeOf(', 'MapType.IsSubtypeOf(mapType, ')
    code = code.replaceAll('type.IsSubtypeOf(', 'MapType.IsSubtypeOf(type, ')
    code = code.replaceAll('throw new ArgumentException("Lump object " + MethodBase.GetCurrentMethod().DeclaringType.Name + " does not exist in map type " + mapType + " or has not been implemented.");', 'throw new Error(`Lump object \'REPLACEME\' does not exist in map type ${mapType} or has not been implemented.`)')
    code = code.replaceAll('bsp.MapType', 'bsp.mapType')

    return code;
}

const code = `

`

const result = parseAndReplace(code)
console.log(result)
